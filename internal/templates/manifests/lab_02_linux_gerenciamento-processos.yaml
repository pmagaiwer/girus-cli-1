apiVersion: v1
kind: ConfigMap
metadata:
  name: linux-gerenciamento-processos-lab
  namespace: girus
  labels:
    app: girus-lab-template
data:
  lab.yaml: |
    name: linux-gerenciamento-processos
    title: "Gerenciamento e Monitoramento de Processos no Linux"
    description: "Aprenda a monitorar, controlar e gerenciar processos no sistema Linux usando ferramentas nativas como ps, top, kill e pgrep. Este laboratório guiado explora conceitos fundamentais de processos em sistemas operacionais Linux, incluindo hierarquia de processos, estados, sinais e técnicas para identificação de problemas de desempenho."
    duration: 30m
    image: "linuxtips/girus-devops:0.1"
    tasks:
      - name: "Conceitos Fundamentais de Processos Linux"
        description: "Compreenda o que são processos no Linux, como são organizados e gerenciados pelo kernel."
        steps:
          - "**O que são Processos no Linux?**"
          - "No Linux, um processo é uma instância de um programa em execução. Cada processo possui:"
          - "- Um identificador único chamado PID (Process ID)"
          - "- Um espaço de memória isolado"
          - "- Recursos do sistema alocados pelo kernel"
          - "- Um estado de execução (running, sleeping, stopped, zombie, etc.)"
          - "- Permissões baseadas no usuário que o executou"
          - "**Hierarquia de Processos**"
          - "O Linux organiza processos em uma estrutura hierárquica pai-filho:"
          - "- Todo processo (exceto o processo init/systemd, PID 1) tem um processo pai"
          - "- Processos podem criar processos filhos através da chamada de sistema <code>fork()</code>"
          - "- Se um processo pai termina antes de seus filhos, estes se tornam 'órfãos' e são adotados pelo processo init/systemd"
          - "- Se um processo filho termina, ele se torna um 'zumbi' até que seu pai chame <code>wait()</code> para obter seu status de saída"
          - "**Estados dos Processos**"
          - "Os processos Linux podem estar em diferentes estados:"
          - "- **Running (R)**: Em execução ou pronto para executar"
          - "- **Sleeping**: Esperando por um evento ou recurso"
          - "  - **Interruptible (S)**: Pode ser acordado por sinais"
          - "  - **Uninterruptible (D)**: Não responde a sinais (geralmente esperando por I/O)"
          - "- **Stopped (T)**: Processo pausado, geralmente por um sinal SIGSTOP"
          - "- **Zombie (Z)**: Processo terminado, mas seu pai não recolheu o status de saída"
          - "**Sinais**"
          - "O Linux usa sinais como um mecanismo de comunicação entre processos:"
          - "- SIGHUP (1): Tradicionalmente usado para recarregar configurações"
          - "- SIGINT (2): Interrupção (equivalente a pressionar Ctrl+C)"
          - "- SIGKILL (9): Termina o processo imediatamente, não pode ser ignorado"
          - "- SIGTERM (15): Solicita término gracioso (padrão do comando kill)"
          - "- SIGSTOP (19): Pausa o processo, não pode ser ignorado"
          - "Vamos explorar na prática como visualizar e gerenciar processos."
        tips:
          - type: "info"
            title: "Prioridade de Processos"
            content: "No Linux, cada processo tem um valor de 'nice' que determina sua prioridade. Valores menores significam maior prioridade. O intervalo vai de -20 (mais prioritário) a 19 (menos prioritário)."
          - type: "tip"
            title: "Diferença entre Thread e Processo"
            content: "No Linux, threads são implementadas como processos (chamados LWP - Light Weight Process) que compartilham recursos como espaço de memória. O comando 'ps -eLf' lista threads como processos individuais."
          - type: "warning"
            title: "Processos Zumbis"
            content: "Processos zumbis consomem uma pequena quantidade de recursos do sistema. No entanto, um grande número deles pode indicar um problema no programa pai, que não está gerenciando corretamente seus filhos."
        validation:
          - command: "ps -p 1 -o comm= | grep -qE 'systemd|init' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "Não foi possível verificar o processo init/systemd (PID 1). Verifique se o sistema está funcionando corretamente."

      - name: "Visualizando e Monitorando Processos"
        description: "Aprenda a usar as ferramentas ps e top para obter informações detalhadas sobre processos em execução no sistema."
        steps:
          - "**Comandos ps: Listagem Estática de Processos**"
          - "O comando <code>ps</code> (process status) é uma das ferramentas mais fundamentais para visualizar processos. Ele captura um instantâneo dos processos ativos no momento da execução."
          - "**Lista básica de processos:**"
          - "`ps`"
          - "Por padrão, ps mostra apenas os processos associados ao seu terminal atual."
          - "**Lista completa de todos os processos:**"
          - "`ps aux`"
          - "Onde:"
          - "- <code>a</code>: Mostra processos de todos os usuários"
          - "- <code>u</code>: Formato orientado ao usuário com mais detalhes"
          - "- <code>x</code>: Inclui processos sem terminal de controle"
          - "**Analisando a saída do ps aux:**"
          - "Cada coluna fornece informações importantes sobre os processos:"
          - "- **USER**: Usuário que executou o processo"
          - "- **PID**: ID do processo"
          - "- **%CPU**: Porcentagem de uso da CPU"
          - "- **%MEM**: Porcentagem de uso da memória física"
          - "- **VSZ**: Tamanho virtual da memória em KB"
          - "- **RSS**: Tamanho da memória física residente em KB"
          - "- **TTY**: Terminal associado ao processo"
          - "- **STAT**: Estado do processo (R=running, S=sleeping, T=stopped, Z=zombie, etc.)"
          - "- **START**: Hora de início do processo"
          - "- **TIME**: Tempo acumulado de CPU"
          - "- **COMMAND**: Comando executado"
          - "**Visualizando hierarquia de processos:**"
          - "`ps auxf`"
          - "A opção <code>f</code> mostra os processos em uma árvore, facilitando a visualização da hierarquia pai-filho."
          - "**Filtrando processos específicos:**"
          - "`ps aux | grep bash`"
          - "Este comando lista todos os processos e filtra apenas aqueles que contêm 'bash' no nome."
          - "**Visualizando informações específicas:**"
          - "`ps -eo pid,ppid,cmd,%cpu,%mem --sort=-%cpu`"
          - "Este comando personalizado mostra PID, PPID (ID do processo pai), comando, uso de CPU e memória, ordenados por uso de CPU."
          - "**Top: Monitoramento Dinâmico em Tempo Real**"
          - "Enquanto o <code>ps</code> fornece um instantâneo estático, o <code>top</code> oferece uma visão dinâmica, atualizando-se regularmente."
          - "`top`"
          - "A primeira parte mostra estatísticas do sistema, incluindo:"
          - "- Uptime e carga média"
          - "- Número total de processos e seus estados"
          - "- Uso de CPU (us=usuário, sy=sistema, ni=nice, id=idle, wa=espera de I/O, etc.)"
          - "- Uso de memória e swap"
          - "A segunda parte mostra a lista de processos, que pode ser ordenada e filtrada interativamente."
          - "**Comandos interativos úteis no top:**"
          - "- <code>P</code>: Ordena por uso de CPU (padrão)"
          - "- <code>M</code>: Ordena por uso de memória"
          - "- <code>T</code>: Ordena por tempo de execução"
          - "- <code>k</code>: Envia um sinal para um processo (permite matar processos)"
          - "- <code>r</code>: Altera a prioridade nice de um processo"
          - "- <code>c</code>: Alterna entre mostrar o comando completo ou resumido"
          - "- <code>h</code> ou <code>?</code>: Mostra ajuda"
          - "- <code>q</code>: Sai do top"
          - "**Versão não interativa do top (útil para scripts):**"
          - "`top -bn1 | head -n 15`"
          - "Este comando executa top em modo batch (<code>-b</code>) por apenas uma iteração (<code>-n1</code>) e mostra as primeiras 15 linhas."
          - "**Alternativas ao top:**"
          - "O Linux oferece alternativas mais avançadas para monitoramento:"
          - "- <code>htop</code>: Versão melhorada do top com interface colorida e interativa"
          - "- <code>atop</code>: Registra atividade para análise histórica"
          - "- <code>glances</code>: Ferramenta abrangente com muitas métricas"
          - "Estes utilitários podem não estar disponíveis em todas as distribuições por padrão, mas são ferramentas valiosas para monitoramento avançado."
        tips:
          - type: "info"
            title: "Entendendo a Carga Média"
            content: "Os três números mostrados na carga média (load average) representam a média de processos na fila de execução nos últimos 1, 5 e 15 minutos, respectivamente. Uma carga maior que o número de CPUs geralmente indica um sistema sobrecarregado."
          - type: "tip"
            title: "Filtros Avançados no ps"
            content: "Use opções como '-C' para filtrar por nome de comando ('ps -C nginx'), '-U' para filtrar por usuário ('ps -U root'), ou '-t' para filtrar por terminal ('ps -t pts/0')."
          - type: "warning"
            title: "Interpretando Uso de Memória"
            content: "O Linux utiliza memória não alocada para cache de disco. Por isso, um sistema pode parecer estar com pouca memória livre, mas na verdade está usando memória de forma eficiente para cache, que pode ser liberada quando necessário."
        validation:
          - command: "ps aux | grep $$ | grep bash &> /dev/null && echo 'ok'" # Verifica se o processo do shell atual (bash) é listado
            expectedOutput: "ok"
            errorMessage: "O comando 'ps aux' não parece estar listando o processo do shell atual."
          - command: "top -bn1 | head -n 1 | grep -q 'top' && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O comando 'top -bn1' não está funcionando como esperado."

      - name: "Encontrando e Filtrando Processos Específicos"
        description: "Aprenda a localizar processos com base em diferentes critérios usando pgrep, pidof e técnicas de filtragem."
        steps:
          - "**Ferramentas para Encontrar Processos**"
          - "O Linux oferece várias ferramentas especializadas para encontrar processos específicos:"
          - "**pgrep: Encontrando Processos por Nome e Atributos**"
          - "Vamos iniciar alguns processos para experimentação:"
          - "`sleep 300 &`"
          - "`sleep 600 &`"
          - "O comando <code>pgrep</code> é projetado especificamente para encontrar PIDs com base em critérios de pesquisa:"
          - "`pgrep sleep`"
          - "Este comando retorna os PIDs de todos os processos <code>sleep</code> em execução."
          - "**Opções úteis do pgrep:**"
          - "- <code>-f</code>: Corresponde ao padrão em toda a linha de comando, não apenas no nome do processo"
          - "`pgrep -f 'sleep 3'`"
          - "- <code>-l</code>: Lista o nome do processo junto com o PID"
          - "`pgrep -l sleep`"
          - "- <code>-a</code>: Lista o comando completo junto com o PID"
          - "`pgrep -a sleep`"
          - "- <code>-u</code>: Filtra por usuário"
          - "`pgrep -u $(id -u) sleep`"
          - "- <code>-v</code>: Inverte a correspondência (processos que não correspondem)"
          - "`pgrep -v sleep`"
          - "- <code>-n</code>: Lista apenas o processo mais recente"
          - "`pgrep -n sleep`"
          - "- <code>-o</code>: Lista apenas o processo mais antigo"
          - "`pgrep -o sleep`"
          - "**pidof: Uma Alternativa Direta**"
          - "O comando <code>pidof</code> é uma alternativa mais simples que retorna os PIDs de um programa específico:"
          - "`pidof sleep`"
          - "**Filtragem Avançada com ps e grep**"
          - "Para pesquisas mais complexas, podemos combinar <code>ps</code> com <code>grep</code>:"
          - "`ps aux | grep '[s]leep'`"
          - "O padrão <code>[s]leep</code> impede que o próprio comando grep apareça nos resultados."
          - "**Encontrando processos por uso de recursos:**"
          - "`ps aux --sort=-%cpu | head -n 5`"
          - "Este comando lista os 5 processos que mais consomem CPU."
          - "`ps aux --sort=-%mem | head -n 5`"
          - "Este comando lista os 5 processos que mais consomem memória."
          - "**Armazenando PIDs em variáveis para uso posterior:**"
          - "`SLEEP_PID=$(pgrep -f 'sleep 300' | head -n 1)`"
          - "`echo \"O PID do processo 'sleep 300' é: $SLEEP_PID\"`"
          - "Esta técnica é especialmente útil em scripts para automatizar o gerenciamento de processos."
        tips:
          - type: "tip"
            title: "pgrep vs ps | grep"
            content: "Usar 'pgrep' é geralmente mais seguro e eficiente do que 'ps aux | grep nome_processo', pois evita encontrar o próprio comando grep na lista e foi especificamente projetado para este fim."
          - type: "info"
            title: "Expressões Regulares"
            content: "Tanto pgrep quanto o grep aceitam expressões regulares para filtragem mais sofisticada. Por exemplo, 'pgrep -f \"sleep (300|600)\"' encontraria processos com sleep 300 ou sleep 600."
          - type: "warning"
            title: "Processo com Múltiplas Instâncias"
            content: "Quando um processo tem várias instâncias, como servidores web ou bancos de dados, verifique cuidadosamente qual instância específica você deseja gerenciar, possivelmente usando o argumento completo do comando com 'pgrep -f'."
        validation:
          - command: "pgrep sleep &> /dev/null && echo 'found'"
            expectedOutput: "found"
            errorMessage: "Não foi possível encontrar o processo 'sleep' usando pgrep. Certifique-se de que ele está em execução."
          - command: "pidof sleep &> /dev/null && echo 'found'"
            expectedOutput: "found"
            errorMessage: "Não foi possível encontrar o processo 'sleep' usando pidof. Certifique-se de que ele está em execução."

      - name: "Gerenciando Processos com Sinais"
        description: "Aprenda a controlar comportamentos de processos enviando diferentes sinais através de comandos como kill, killall5 e pkill."
        steps:
          - "**Entendendo Sinais e sua Importância**"
          - "Sinais são uma forma de comunicação inter-processo (IPC) no Linux para controlar o comportamento dos processos. Eles são usados para notificar um processo sobre eventos específicos, como:"
          - "- Solicitações para terminar sua execução"
          - "- Indicações para pausar ou retomar operações"
          - "- Pedidos para recarregar sua configuração"
          - "**Listando Sinais Disponíveis**"
          - "Para ver todos os sinais disponíveis no sistema:"
          - "`kill -l`"
          - "Os sinais mais comuns incluem:"
          - "- **SIGHUP (1)**: Hang up, tradicionalmente usado para recarregar configurações"
          - "- **SIGINT (2)**: Interrupt, enviado quando você pressiona Ctrl+C"
          - "- **SIGQUIT (3)**: Quit, enviado quando você pressiona Ctrl+\""
          - "- **SIGKILL (9)**: Kill, força o término imediato (não pode ser capturado ou ignorado)"
          - "- **SIGTERM (15)**: Terminate, solicita término gracioso (padrão do comando kill)"
          - "- **SIGSTOP (19)**: Stop, pausa a execução (não pode ser capturado)"
          - "- **SIGCONT (18)**: Continue, retoma a execução após um SIGSTOP"
          - "**Usando o Comando kill**"
          - "O comando <code>kill</code> envia sinais para processos específicos por PID:"
          - "Primeiro, vamos verificar e capturar um PID de um processo 'sleep':"
          - "`PID_SLEEP=$(pgrep sleep | head -n 1)`"
          - "`echo \"Enviando sinal para o processo sleep (PID: $PID_SLEEP)\"`"
          - "Enviar sinal de terminação padrão (SIGTERM):"
          - "`kill $PID_SLEEP`"
          - "O processo sleep deve terminar de forma limpa. Verifique se ele foi encerrado:"
          - "`sleep 1; pgrep -f \"^sleep\" | grep -q $PID_SLEEP || echo 'Processo terminado'`"
          - "**Utilizando outros sinais com kill**"
          - "Vamos iniciar outro processo sleep:"
          - "`sleep 300 &`"
          - "`PID_SLEEP=$(pgrep sleep | head -n 1)`"
          - "Enviar SIGSTOP para pausar a execução:"
          - "`kill -STOP $PID_SLEEP`"
          - "Verificar estado do processo (T = stopped):"
          - "`ps -p $PID_SLEEP -o pid,state,cmd`"
          - "Enviar SIGCONT para retomar a execução:"
          - "`kill -CONT $PID_SLEEP`"
          - "Verificar estado do processo novamente (deverá mudar para S ou R):"
          - "`ps -p $PID_SLEEP -o pid,state,cmd`"
          - "Usar SIGKILL quando um processo não responde:"
          - "`kill -9 $PID_SLEEP`"
          - "Verificar se o processo foi encerrado:"
          - "`sleep 0.5; ps -p $PID_SLEEP &>/dev/null || echo 'Processo eliminado com SIGKILL'`"
          - "**Comandos killall e pkill**"
          - "O comando <code>killall</code> envia sinais para processos com base em seus nomes."
          - "O comando <code>killall</code> não vem instalado por padrão em ambientes SystemV (que é o ambiente utilizado em nosso laboratório). Use o comando abaixo para instalá-lo:"
          - "`sudo apt update && sudo apt install -y psmisc`"
          - "Inicie vários processos sleep:"
          - "`sleep 200 & sleep 250 & sleep 300 &`"
          - "Encerre todos os processos sleep de uma vez:"
          - "`killall sleep`"   
          - "Verifique se foram encerrados:"
          - "`pgrep sleep || echo 'Todos os processos sleep foram encerrados'`"
          - "O comando <code>pkill</code> é mais flexível, combinando recursos do pgrep e do kill:"
          - "Inicie alguns processos:"
          - "`sleep 100 & sleep 200 & sleep 300 &`"
          - "Encerre apenas processos com um padrão específico:"
          - "`pkill -f 'sleep 2'`"
          - "Isso encerrará processos sleep com argumento '200' ou '300', mas não '100'."
          - "Verifique quais processos restaram:"
          - "`pgrep -fa sleep`"
          - "Encerre todos os restantes:"
          - "`pkill sleep`"
        tips:
          - type: "warning"
            title: "Uso do SIGKILL (kill -9)"
            content: "SIGKILL força a terminação imediata de um processo sem permitir que ele limpe recursos ou salve dados. Use apenas como último recurso quando SIGTERM falhar, pois pode causar inconsistências de dados ou recursos órfãos."
          - type: "info"
            title: "Processos 'Unkillable'"
            content: "Processos em estado D (uninterruptible sleep) não podem ser interrompidos mesmo com SIGKILL. Estes processos geralmente estão aguardando operações de I/O e só terminarão quando essa operação for concluída ou o sistema for reiniciado."
          - type: "tip"
            title: "Gerenciando Grupos de Processos"
            content: "Para matar um processo e todos os seus filhos, use o sinal negativo com kill: 'kill -TERM -$PID' envia o sinal para todo o grupo de processos associado ao PID especificado."
          - type: "info"
            title: "Comando 'killall' no SystemV"
            content: "O comando `killall` não vem instalado por padrão em ambientes SystemV (que é o ambiente utilizado em nosso laboratório)."
        validation:
          - command: "pgrep sleep || echo 'killed'"
            expectedOutput: "killed"
            errorMessage: "Algum processo 'sleep' ainda está em execução após os comandos de terminação."
          - command: "kill -l | grep -q SIGKILL && echo 'ok'"
            expectedOutput: "ok"
            errorMessage: "O comando 'kill -l' não mostra a lista completa de sinais disponíveis."
